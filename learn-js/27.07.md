**Команда Debugger**  
Выполнение кода можно также приостановить с помощью команды debugger прямо изнутри самого кода.

**Behavior Driven Development (BDD)**  
BDD – это три в одном: и тесты, и документация, и примеры использования.
В BDD сначала пишут спецификацию, а потом реализацию. В конце у нас есть и то, и другое.
Спецификацию можно использовать тремя способами:
  Как Тесты – они гарантируют, что функция работает правильно.
  Как Документацию – заголовки блоков describe и it описывают поведение функции.
  Как Примеры – тесты, по сути, являются готовыми примерами использования функции.
  
**Babel**  
Babel – это транспилер. Он переписывает современный JavaScript-код в предыдущий стандарт.
Два интересных хранилища полифилов:
core js поддерживает много функций, можно подключать только нужные.
polyfill.io – сервис, который автоматически создаёт скрипт с полифилом в зависимости от необходимых функций и браузера пользователя.

**Объекты**  
Вычисляемые свойства:
  Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.
  Пример:
  let fruit = prompt("Какой фрукт купить?", "apple");
  let bag = {
    [fruit]: 5, // имя свойства будет взято из переменной fruit
  };
  alert( bag.apple ); // 5, если fruit="apple"

Термин «целочисленное свойство» означает строку, которая может быть преобразована в целое число и обратно без изменений.
Объекты – это ассоциативные массивы с рядом дополнительных возможностей.

**Сборка мусора**  
Достижимость
Основной концепцией управления памятью в JavaScript является принцип достижимости.
Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти.
Существует базовое множество достижимых значений, которые не могут быть удалены.
Например:
Локальные переменные и параметры текущей функции.
Переменные и параметры других функций в текущей цепочке вложенных вызовов.
Глобальные переменные.
(некоторые другие внутренние значения)
Эти значения мы будем называть корнями.
Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.
Cборщик мусора cледит за всеми объектами и удаляет те, которые стали недостижимы.

Основной алгоритм сборки мусора – «алгоритм пометок» (англ. «mark-and-sweep»).
Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:
Сборщик мусора «помечает» (запоминает) все корневые объекты.
Затем он идёт по их ссылкам и помечает все найденные объекты.
Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка от них. Все объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
…И так далее, пока не будут посещены все ссылки (достижимые от корней).
Все непомеченные объекты удаляются.

Интерпретаторы JavaScript применяют множество оптимизаций, чтобы сборка мусора работала быстрее и не влияла на производительность.
Вот некоторые из оптимизаций:
Сборка по поколениям (Generational collection) – объекты делятся на «новые» и «старые». 
Инкрементальная сборка (Incremental collection)
Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.
**Сравнение Object.is**  
Существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:
Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.
Во всех других случаях Object.is(a, b) идентичен a === b.
Этот способ сравнения часто используется в спецификации JavaScript. Когда внутреннему алгоритму необходимо сравнить 2 значения на предмет точного совпадения, он использует Object.is
**Объекты, которые можно использовать в цикле for..of, называются итерируемыми.**  
**Объекты, имеющие индексированные свойства и length, называются псевдомассивами. Они также могут иметь другие свойства и методы, но у них нет встроенных методов массивов.**  
